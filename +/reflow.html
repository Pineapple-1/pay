<style>
    /* apply extra formatting to fix divs in place while font size changes within them */
    .memo {
        height: 31px;
    }
    .payee {
        height: 29px
    }
    .amount {
        height: 32px;
    }
    .amounts {
        height: 31px;
    }
    .endorse {
        height: 48px;
    }
    .endorse.overflow .font {
        height: 48px;
        display: flex;
        align-items: flex-end; /* stick text to bottom of box even as it shrinks */
    }

    .amount.overflow, .amounts.overflow {
        display: flex;
        align-items: center;
        text-align: center;
    }

    .amount.overflow .font {
        left: 10px; /* scoot full width text over a smidge */
    }

    .amounts:not(.overflow) .font[style]:not(:focus):after {
        /* only apply a trailing dash on field with explicit style tag -- that's the attr used to pass the css var, if its not there, don't dash */
        display: inline-block;
        content: '-';
        transform: scale(var(--dash),1);
        transform-origin: left;
        pointer-events: none;
    }
</style>
<script>
;(function(){
    $.fn.getBoundingClientRect = function() {
        return this.get(0).getBoundingClientRect()
    }
    $.fn.getBoundingClientText = function() {
        // must call in field for all css to apply to clone in order to measure the span
        // get the text node, wrap it in a span, measure the span, discard the clone
        var range = document.createRange();
        var text = this.get(0)
        if(!text){ return 0 }
        range.setStart(text, 0);
        range.setEnd(text, text.length);
        return range.getBoundingClientRect();
    };

    $('.amount, .amounts, .memo, .payee, .signature, .endorse').each(function(){
        // I have to call reflow on load for each of these anyway, so might as well attach the listeners here
        // allowing me to target the specified parent div as target of reflow, without accessing event object
        var target = $(this)
        target.keyup(() => reflow(target))
        target.children().first().blur(() => reflow(target))
        reflow(target);
    })

    function reflow(field){
        var font = field.children().first();
        var text = font.contents().first();
        
        if(!text.text()){  /* reset things and exit if field is empty */
            font.removeAttr('style');
            field.removeClass('overflow');
            return;
        }

        var current, original, scaled, factor;
        
        current = parseFloat(font.css('font-size')); // will return calc(Xpx) if scaled has been applied, or px units if no scaled has been applied
        original = parseFloat(field.css('font-size')); // get the unmodified font size in px units // I'm using the font-size of the parent element as original, because this reads the calculated size

        var fieldSize = field.getBoundingClientRect()
        var textSize = text.getBoundingClientText()

        if(field.hasClass('endorse')){
            factor = fieldSize.height / textSize.height; // lol we're sideways
        } else {
            factor = fieldSize.width / textSize.width;
        }

        scaled = (current * factor * .9).toFixed(2); // 0.9 is a fudge factor

        if(scaled > original){
            // reflow size would be larger than original, which means there would be no overflow with original size. remove overflow styling and exit
            // since scaled text is 
            font.attr('style', '--dash: ' + ((fieldSize.width - textSize.width) / (original / 1.5)).toFixed(2));
            field.removeClass('overflow');
            font.css('font-size',''); // clear any existing font-size rule
        } else {
            // if reflow'd font-size is less than original, then we better used the reflow'd font-size to fit in the box, and add overflow styling
            font.removeAttr('style');
            field.addClass('overflow');
            font.css('font-size', scaled + 'px')
        }
    }
})();
</script>